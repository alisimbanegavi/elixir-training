VIEWS----------------------------------------------------------------------------------------------
- Main job is to render the body of responses to be sent back to browsers and API clients
- Given a bag of data, the view's purpose is to present that in a meaningful way given some format, be it HTML, JSON, CSV, or others
- Essentially, main role is data presentation

RENDERING TEMPLATES----------------------------------------------------------------------------------------------
- Phoenix assumes a strong naming convention from controllers to views to the templates they render
- PageController requires a PageView to render templates in directory 'lib/hello_web/templates/page'
- Newly generated Phoenix app has 3 view modules (all contained in 'lib/hello_web/views')
    - ErrorView                           - LayoutView                          -PageView

LAYOUTVIEW~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Ex) defmodule HelloWeb.LayoutView do
        use HelloWeb, :view
    end

- This calls view/0 which exercises the __using__ macro in the Phoenix.View module
- Also handles module imports or aliases our app's view modules may need

- All of the imports and aliases we make in our view will also be available in our template
    - Bc templates are compiled into functions inside their respective views
- So if you define a function in your view, you will be able to invoke it directly from the template

Ex) title/0 function
    
    - layout_view.exs: 
        ...
        def title() do
            "Awesome New Title!"
        end
        ...

    - app.html.eex:7:
        ...
        <title><%= title() %></title>
        ...

- Embedded Elixir (EEx) expressions can be executed using this format: <%= expression %>
- Result is interpolated into the template

Ex) Conditional
    <%= if some_condition? do %>
        <p>Some condition is true for user: <%= @user.name %></p>
    <% else %>
        <p>Some condition is false for user: <%= @user.name %></p>
    <% end %>

Ex) Loop
    <table>
        <tr>
            <th>Number</th>
            <th>Power</th>
        </tr>
        <%= for number <- 1..10 do %>
        <tr>
            <td><%= number %></td>
            <td><%= number * number %></td>
        </tr>
        <% end %>
    </table>


TEMPLATE COMPILATION~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- When a template is compiled into a view, it is simply compiled as a render function that expects two arguments:
    - Template name
    - Assigns
    *** Example in 'hello_web/views/page_view.ex'
- By defining our own clause in render, it takes higher priority than the template
    - The template is still there, which we can verify by simply removing the newly added clause
- At compile-time, Phoenix precompiles all *.html.eex templates and turns them into render/2 function clauses on their respective view modules
- At runtime, all templates are already loaded in memory (no disk reads, complex file caching, or template engine computation involved)

MANUAL TEMPLATE RENDERING~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- We can render views directly
Ex) hello_web/templates/page/test.html.eex :
    > This is the message: <%= @message %>

    - We can run 'iex -S mix' then explicitly render our template:
        iex> Phoenix.View.render(HelloWeb.PageView, "test.html", message: "Hello from IEx!")
        output>  {:safe, ["This is the message: ", "Hello from IEx!"]}

    - We're calling render/3 with the individual view responsible for:
        - Test template 
        - Name of our test template
        - Empty map representing any assigns we might have wanted to pass in
    - Return value is tuple
        - Beginning with atom ':safe' (means Phoenix has escaped the contents of our rendered template to avoid XSS injection attacks)
        - Also contains resultant io list of interpolated template
    - If we only need a rendered string and not a whole tuple, we use render_to_string/3
        iex> Phoenix.View.render_to_string(HelloWeb.PageView, "test.html", message: "Hello from IEx!")
        output> "This is the message: Hello from IEx!"


SHARING VIEWS & TEMPLATES----------------------------------------------------------------------------------------------
- We can share views and templates from inside other views and templates
    - i.e. If you want to render the "test.html" template from inside our layout, you can invoke render/3 directly from the layout:
        <%= Phoenix.View.render(HelloWeb.PageView, "test.html", message: "Hello from layout!") %>

- If you want to render a template within the same view
    - Skip the view name
    - Simply call i.e. render("test.html", message: "Hello from sibling template!")

LAYOUTS----------------------------------------------------------------------------------------------
- Layouts are just templates
- Have a view (just like other templates)
    - In a newly generated app, the view is in i.e. 'hello_web/views/layout_view.ex'
- The string resulting from a rendered view ends up inside a layout

RENDERING JSON----------------------------------------------------------------------------------------------
- Many web apps today return JSON to remote clients, and Phoenix Views are great for JSON rendering
- Phoenix uses Jason to encode JSON so all we need to do in our views is format the data we'd like to respond with as a list or a map and Phoenix will do the rest
- While it is possible to respond with JSON back directly from the controller and skip the view, Phoenix Views provide a much more structured approach for doing so

Ex) hello_web/controllers/page_controller.ex - respond with some static page maps as JSON rather than HTML
...
  def show(conn, _params) do
    page = %{title: "foo"}

    render(conn, "show.json", page: page)
  end

  def index(conn, _params) do
    pages = [%{title: "foo"}, %{title: "bar"}]

    render(conn, "index.json", pages: pages)
  end
...
    - Instead of passing in "show.html" to render/3 as the template name, we pass "show.json"
    - Lets us have views that are responsible for rendering HTML and/or JSON by pattern matching on different file types

Ex 2) hello_web/views/page_view.ex:
...
    def render("index.json", %{pages: pages}) do
    %{data: render_many(pages, HelloWeb.PageView, "page.json")}
  end

  def render("show.json", %{page: page}) do
    %{data: render_one(page, HelloWeb.PageView, "page.json")}
  end

  def render("page.json", %{page: page}) do
    %{title: page.title}
  end
...

    - In the view we see our render/2 function pattern matching on "index.json", "show.json", and "page.json"
        - The "index.json" and "show.json" are the ones requested directly from the controller
        - They also match on the assigns sent by the controller.
    - Rendering index.json response:

        {
            "data": 
            [
                {
                    "title": "foo"
                },
                {
                    "title": "bar"
                },
            ]
        }

    - Rendering show.json response"

        {
        "data": {
            "title": "foo"
            }
        }

    - This works because both "index.json" and "show.json" builds themselves on top of an internal "page.json" clause

RENDER FUNCTIONS~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- The render_many/3 function takes 
    - The data we want to respond with (pages)
    - A view
    - A string to pattern match on the render/2 function defined on view
- It will map over each item in pages, and call PageView.render("page.json", %{page: page})
- render_one/3 follows the same signature ultimately using the render/2 matching page.json to specify what each page looks like
- It's useful to build our views like this so they can be composable

ex) Author module
     - Imagine a situation where our Page has a has_many relationship with Author
     - Depending on the request, we may want to send back author data with the page
     - We can easily accomplish this with a new render/2 in page_view.ex:

    def render("page_with_authors.json", %{page: page}) do
        %{title: page.title,
        authors: render_many(page.authors, AuthorView, "author.json")}
     end

    - The name used in assigns is determined from the view
    - For example the PageView will use %{page: page} while AuthorView will use %{author: author}
    - This can be overridden with the as option
    - Let's assume that the author view uses %{writer: writer} instead of %{author: author}:

    def render("page_with_authors.json", %{page: page}) do
        %{title: page.title,
        authors: render_many(page.authors, AuthorView, "author.json", as: :writer)}
    end

ERROR PAGES---------------------------------------------------------------------------------------------
- Phoenix has a view called the ErrorView which lives in lib/hello_web/views/error_view.ex
- Purpose of the ErrorView is to handle errors in a general way, from one centralized location
- Similar to the views we built in this guide, error views can return both HTML and JSON responses